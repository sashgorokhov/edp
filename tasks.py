import json
import os
import re
import shutil
from pathlib import Path
from typing import Optional, List

import invoke
import requests
from invoke import Context, Exit

BASE_DIR: Path = Path(__file__).parent
GUI_DIR: Path = BASE_DIR / 'edp' / 'gui'
UI_DIR: Path = GUI_DIR / 'ui'
COMPILED_DIR: Path = GUI_DIR / 'compiled'

UPX_URL = 'https://github.com/upx/upx/releases/download/v3.95/upx-3.95-win64.zip'
LOCAL_TEMP_DIR: Path = BASE_DIR / '.tmp'
UPX_DIR: Path = LOCAL_TEMP_DIR / 'upx'
TARGET: Path = BASE_DIR / 'elite_dangerous_platform.py'
DIST_DIR: Path = BASE_DIR / 'dist' / TARGET.stem
DIST_ZIP: Path = DIST_DIR.with_suffix('.zip')
EXE_FILE: Path = DIST_DIR / TARGET.with_suffix('.exe').name
DIST_DATA_FILE: Path = DIST_DIR / 'dist.json'

LOCAL_TEMP_DIR.mkdir(parents=True, exist_ok=True)

GITHUB_API_TOKEN: Optional[str] = os.environ.get('GITHUB_API_TOKEN')
SENTRY_DSN: Optional[str] = os.environ.get('SENTRY_DSN')


@invoke.task
def pyuic(c):
    from PyQt5.uic import compileUi

    for path in UI_DIR.glob('*.ui'):
        target_path = COMPILED_DIR / path.with_suffix('.py').name
        print(f'Compiling {path.name} to {target_path}')
        compileUi(str(path), target_path.open('w'))


def gethashsum(path, md5=False, sha1=False):
    import hashlib

    path = Path(path)
    if not path.exists():
        raise FileNotFoundError(path)
    if path.is_dir():
        raise IsADirectoryError(path)

    if md5:
        hashobj = hashlib.md5()
    elif sha1:
        hashobj = hashlib.sha1()
    else:
        return

    with path.open('rb') as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            hashobj.update(data)

    hashsum = hashobj.hexdigest()
    return hashsum


def fetch_upx(c: Context):
    global UPX_DIR

    UPX_ZIP = UPX_DIR.with_suffix('.zip')
    if UPX_ZIP.exists():
        UPX_ZIP.unlink()
    print(f'Fetching UPX form {UPX_URL}')
    response = requests.get(UPX_URL, stream=True)
    with UPX_ZIP.open('wb') as f:
        for chunk in response.iter_content(chunk_size=None):
            f.write(chunk)
    c.run(f'powershell Expand-Archive -Force -Path {UPX_ZIP} -DestinationPath {UPX_DIR}')
    UPX_DIR = next(UPX_DIR.iterdir())
    print(f'UPX now is in {UPX_DIR}')


@invoke.task()
def mypy(c):
    c.run('mypy edp')


@invoke.task()
def pylint(c):
    c.run('pylint edp', warn=True)


@invoke.task()
def unittests(c):
    c.run('pytest -sv tests')


@invoke.task(mypy, pylint, unittests)
def test(c):
    pass


@invoke.task
def build(c):
    if not UPX_DIR.exists():
        fetch_upx(c)

    c.run(f'pyinstaller -w -y --clean --log-level WARN --upx-dir {UPX_DIR} {TARGET}')
    shutil.copy(str(BASE_DIR / 'VERSION'), str(DIST_DIR / 'VERSION'))
    if not SENTRY_DSN:
        print('SENTRY_DSN is not set!')
    DIST_DATA_FILE.write_text(json.dumps({
        'SENTRY_DSN': SENTRY_DSN
    }))


@invoke.task(build)
def dist(c):
    print(f'Create dist zip in {DIST_ZIP}')
    c.run(f'powershell Compress-Archive -Force -Path {DIST_DIR} -DestinationPath {DIST_ZIP}')


@invoke.task()
def release(c):
    from edp.utils import github
    if not GITHUB_API_TOKEN:
        raise Exit('GITHUB_API_TOKEN is not set')

    md5_exe = gethashsum(EXE_FILE, md5=True)
    md5_zip = gethashsum(DIST_ZIP, md5=True)
    sha1_exe = gethashsum(EXE_FILE, sha1=True)
    sha1_zip = gethashsum(DIST_ZIP, sha1=True)

    commits_lines: List[str] = commits_before_tag(c)
    commits_info = [cl.split(' ', 1) for cl in commits_lines]
    changelog = '\n'.join(f'- {sha} {message}' for sha, message in commits_info)

    body = f"""
### Changelog:

{changelog}

### Hashsums:

MD5 exe: `{md5_exe}`

MD5 zip: `{md5_zip}`

SHA1 exe: `{sha1_exe}`

SHA1 zip: `{sha1_zip}`

---
Generated by ðŸ¤–
    """

    version = '%s.%s.%s' % read_version()

    api = github.GithubApi(GITHUB_API_TOKEN)
    data = api.create_release('sashgorokhov', 'edp',
                              f'v{version}',
                              f'Elite Dangerous Platform v{version}',
                              body, draft=True)
    upload_url = re.sub('{.*?}', '', data['upload_url'])
    print('Uploading assets')
    api.upload_asset(upload_url, DIST_ZIP, 'application/zip', f'EDP-{version}-win64.zip')
    print(data['html_url'])


@invoke.task()
def freeze(c):
    VENV_DIR: Path = LOCAL_TEMP_DIR / 'env'
    PIP: Path = VENV_DIR / 'Scripts' / 'pip.exe'
    c.run(f'virtualenv {VENV_DIR}')
    c.run(f"{PIP} install -Ur requirements-dev.txt")
    c.run(f"{PIP} freeze > constraints.txt")
    shutil.rmtree(VENV_DIR)


def read_version():
    version = (BASE_DIR / 'VERSION').read_text()
    major, minor, patch = tuple(map(int, version.split('.')))
    return major, minor, patch


def commit_version(c):
    version = '%s.%s.%s' % read_version()
    c.run(f'git commit -m "Update VERSION to {version}" {BASE_DIR / "VERSION"}')
    c.run(f'git tag -a -m "v{version}" "v{version}"')
    c.run(f'git push --all')


@invoke.task()
def bump_major(c):
    major, minor, patch = read_version()
    (BASE_DIR / 'VERSION').write_text('.'.join(map(str, (major + 1, 0, 0))))
    commit_version(c)


@invoke.task()
def bump_minor(c):
    major, minor, patch = read_version()
    (BASE_DIR / 'VERSION').write_text('.'.join(map(str, (major, minor + 1, 0))))
    commit_version(c)


@invoke.task()
def bump_patch(c):
    major, minor, patch = read_version()
    (BASE_DIR / 'VERSION').write_text('.'.join(map(str, (major, minor, patch + 1))))
    commit_version(c)


@invoke.task()
def commits_before_tag(c):
    all_tags = list(filter(None, (t.strip() for t in c.run('git tag', hide=True).stdout.split('\n'))))
    previous_tag = all_tags[-2]
    last_tag = all_tags[-1]
    result = c.run(f'git log --pretty=oneline {previous_tag}..{last_tag}').stdout
    return list(filter(None, result.split('\n')))
